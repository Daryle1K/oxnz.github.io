---
layout: post
title: 关于int13与扩展int13
date: 
type: post
published: false
status: private
categories:
- Blog
tags: []
meta:
  _edit_last: '1'
author:
  login: oxnz
  email: yunxinyi@gmail.com
  display_name: Will Z
  first_name: Will
  last_name: Z
---
<table width="460" border="0" cellspacing="0" cellpadding="0" align="center">
<tbody>
<tr>
<td align="center"></td>
</tr>
<tr>
<td height="30"></td>
</tr>
<tr>
<td>
<div id="NewsContentLabel">
<p>第一部分 简 介<br />
1,1<br />
一. 硬盘结构简介<br />
1. 硬盘参数释疑<br />
到目前为止, 人们常说的硬盘参数还是古老的 CHS (Cylinder/Head/Sector)参数. 那么为什么要使用这些参数, 它们的意义是什么? 它们的取值范围是什么? 很久以前, 硬盘的容量还非常小的时候, 人们采用与软盘类似的结构生产硬盘. 也就是硬盘盘片的每一条磁道都具有相同的扇区数. 由此产生了所谓的3D参数 (Disk Geometry). 既磁头数(Heads), 柱面数(Cylinders), 扇区数(Sectors),以及相应的寻址方式.<br />
其中:<br />
磁头数(Heads) 表示硬盘总共有几个磁头,也就是有几面盘片, 最大为 255 (用 8 个二进制位存储); 柱面数(Cylinders) 表示硬盘每一面盘片上有几条磁道, 最大为 1023 (用 10 个二进制位存储); 扇区数(Sectors) 表示每一条磁道上有几个扇区, 最大为 63 (用 6 个二进制位存储).<br />
每个扇区一般是 512个字节, 理论上讲这不是必须的, 但好象没有取别的值的.所以磁盘最大容量为: 255 * 1023 * 63 * 512 / 1048576 = 8024 GB ( 1M = 1048576 Bytes ) 或硬盘厂商常用的单位:<br />
255 * 1023 * 63 * 512 / 1000000 = 8414 GB ( 1M = 1000000 Bytes ) 在 CHS 寻址方式中, 磁头, 柱面, 扇区的取值范围分别为 0 到 Heads - 1, 0 到 Cylinders - 1, 1 到 Sectors (注意是从 1 开始).<br />
2. 基本 Int 13H 调用简介<br />
BIOS Int 13H 调用是 BIOS 提供的磁盘基本输入输出中断调用, 它可以完成磁盘(包括硬盘和软盘)的复位, 读写, 校验, 定位, 诊断, 格式化等功能.它使用的就是 CHS 寻址方式, 因此最大识能访问 8 GB 左右的硬盘 ( 本文中如不作特殊说明, 均以 1M = 1048576 字节为单位).<br />
3. 现代硬盘结构简介<br />
在老式硬盘中, 由于每个磁道的扇区数相等, 所以外道的记录密度要远低于内道, 因此会浪费很多磁盘空间 (与软盘一样). 为了解决这一问题, 进一步提高硬盘容量, 人们改用等密度结构生产硬盘. 也就是说, 外圈磁道的扇区比内圈磁道多. 采用这种结构后, 硬盘不再具有实际的3D参数, 寻址方式也改为线性寻址, 即以扇区为单位进行寻址.为了与使用3D寻址的老软件兼容 (如使用BIOS Int13H接口的软件), 在硬盘控制器内部安装了一个地址翻译器, 由它负责将老式3D参数翻译成新的线性参数. 这也是为什么现在硬盘的3D参数可以有多种选择的原因 (不同的工作模 式, 对应不同的3D参数, 如 LBA, LARGE, NORMAL).<br />
4. 扩展 Int 13H 简介<br />
虽然现代硬盘都已经采用了线性寻址, 但是由于基本 Int 13H 的制约, 使用 BIOS Int 13H 接口的程序, 如 DOS 等还只能访问 8 G 以内的硬盘空间.为了打破这一限制, Microsoft 等几家公司制定了扩展 Int 13H 标准(Extended Int13H), 采用线性寻址方式存取硬盘, 所以突破了 8 G 的限制, 而且还加入了对可拆卸介质 (如活动硬盘) 的支持.<br />
二. Boot Sector 结构简介<br />
1. Boot Sector 的组成<br />
Boot Sector 也就是硬盘的第一个扇区, 它由 MBR (Master Boot Record), DPT (Disk Partition Table) 和 Boot Record ID 三部分组成. MBR 又称作主引导记录占用 Boot Sector 的前 446 个字节 ( 0 to 0x1BD ), 存放系统主引导程序 (它负责从活动分区中装载并运行系统引导程序). DPT 即主分区表占用 64 个字节 (0x1BE to 0x1FD), 记录了磁盘的基本分区信息. 主分区表分为四个分区项, 每项 16 字节, 分别记录了每个主分区的信息(因此最多可以有四个主分区).Boot Record ID 即引导区标记占用两个字节 (0x1FE and 0x1FF), 对于合法引导区, 它等于 0xAA55, 这是判别引导区是否合法的标志.Boot Sector 的具体结构如下图所示:<br />
0000 |------------------------------------------------|<br />
| |<br />
| |<br />
| Master Boot Record |<br />
| |<br />
| |<br />
| 主引导记录(446字节) |<br />
| |<br />
| |<br />
| |<br />
01BD | |<br />
01BE |------------------------------------------------|<br />
| |<br />
01CD | 分区信息 1(16字节) |<br />
01CE |------------------------------------------------|<br />
| |<br />
01DD | 分区信息 2(16字节) |<br />
01DE |------------------------------------------------|<br />
| |<br />
01ED | 分区信息 3(16字节) |<br />
01EE |------------------------------------------------|<br />
| |<br />
01FD | 分区信息 4(16字节) |<br />
|------------------------------------------------|<br />
| 01FE | 01FF |<br />
| 55 | AA |<br />
|------------------------------------------------|<br />
2. 分区表结构简介<br />
分区表由四个分区项构成, 每一项的结构如下:<br />
BYTE State : 分区状态, 0 = 未激活, 0x80 = 激活 (注意此项)<br />
BYTE StartHead : 分区起始磁头号<br />
WORD StartSC : 分区起始扇区和柱面号, 底字节的低6位为扇区号,高2位为柱面号的第 9,10 位, 高字节为柱面号的低 8 位BYTE Type : 分区类型, 如 0x0B = FAT32, 0x83 = Linux 等,<br />
00 表示此项未用<br />
BYTE EndHead : 分区结束磁头号<br />
WORD EndSC : 分区结束扇区和柱面号, 定义同前<br />
DWORD Relative : 在线性寻址方式下的分区相对扇区地址<br />
(对于基本分区即为绝对地址)<br />
DWORD Sectors : 分区大小 (总扇区数)<br />
注意: 在 DOS / Windows 系统下, 基本分区必须以柱面为单位划分( Sectors * Heads 个扇区), 如对于 CHS 为 764/255/63 的硬盘, 分区的最小尺寸为 255 * 63 * 512 / 1048576 = 7.844 MB.<br />
3. 扩展分区简介<br />
由于主分区表中只能分四个分区, 无法满足需求, 因此设计了一种扩展分区格式. 基本上说, 扩展分区的信息是以链表形式存放的, 但也有一些特别的地方.首先, 主分区表中要有一个基本扩展分区项, 所有扩展分区都隶属于它, 也就是说其他所有扩展分区的空间都必须包括在这个基本扩展分区中. 对于DOS / Windows 来说, 扩展分区的类型为 0x05. 除基本扩展分区以外的其他所有扩展分区则以链表的形式级联存放, 后一个扩展分区的数据项记录在前一个扩展分区的分区表中, 但两个扩展分区的空间并不重叠.扩展分区类似于一个完整的硬盘, 必须进一步分区才能使用. 但每个扩展分区中只能存在一个其他分区. 此分区在 DOS/Windows 环境中即为逻辑盘. 因此每一个扩展分区的分区表 (同样存储在扩展分区的第一个扇区中)中最多只能有两个分区数据项(包括下一个扩展分区的数据项). 扩展分区和逻辑盘的示意图如下:<br />
|-----------------------| --------<br />
| 主扩展分区(/dev/hda2) | ^<br />
|-----------------------| |<br />
| 扩 展 | 分区项 1 |-- |<br />
| |------------| | |<br />
| 分区表 | 分区项 2 |--+-- |<br />
|-----------------------| | | |<br />
| | | | |<br />
| 逻辑盘 1 (/dev/hda5) |&lt;-/ | |<br />
| | | |<br />
|-----------------------| | 主<br />
| 扩展分区 2 |&lt;----/<br />
|-----------------------| 扩<br />
| 扩 展 | 分区项 1 |--<br />
| |------------| | 展<br />
| 分区表 | 分区项 2 |--+--<br />
|-----------------------| | | 分<br />
| | | |<br />
| 逻辑盘 2 (/dev/hda6) |&lt;-/ | 区<br />
| | | |<br />
|-----------------------| | |<br />
| 扩展分区 3 |&lt;----/ |<br />
|-----------------------| |<br />
| 扩 展 | 分区项 1 |-- |<br />
| |------------| | |<br />
| 分区表 | 分区项 2 | | |<br />
|-----------------------| | |<br />
| | | |<br />
| 逻辑盘 3 (/dev/hda7) |&lt;-/ |<br />
| | |<br />
|-----------------------| ---------<br />
三. 系统启动过程简介<br />
系统启动过程主要由一下几步组成(以硬盘启动为例):<br />
1. 开机 :-)<br />
2. BIOS 加电自检 ( Power On Self Test -- POST )<br />
内存地址为 0ffff:0000<br />
3. 将硬盘第一个扇区 (0头0道1扇区, 也就是Boot Sector)<br />
读入内存地址 0000:7c00 处.<br />
4. 检查 (WORD) 0000:7dfe 是否等于 0xaa55, 若不等于<br />
则转去尝试其他启动介质, 如果没有其他启动介质则显示<br />
"No ROM BASIC" 然后死机.<br />
5. 跳转到 0000:7c00 处执行 MBR 中的程序.<br />
6. MBR 首先将自己复制到 0000:0600 处, 然后继续执行.<br />
7. 在主分区表中搜索标志为活动的分区. 如果发现没有活动<br />
分区或有不止一个活动分区, 则转停止.<br />
8. 将活动分区的第一个扇区读入内存地址 0000:7c00 处.<br />
9. 检查 (WORD) 0000:7dfe 是否等于 0xaa55, 若不等于则<br />
显示 "Missing Operating System" 然后停止, 或尝试<br />
软盘启动.<br />
10. 跳转到 0000:7c00 处继续执行特定系统的启动程序.<br />
11. 启动系统 ...<br />
以上步骤中 2,3,4,5 步是由 BIOS 的引导程序完成. 6,7,8,9,10<br />
步由MBR中的引导程序完成.<br />
一般多系统引导程序 (如 SmartFDISK, BootStar, PQBoot 等) 都是将标准主引导记录替换成自己的引导程序, 在运行系统启动程序之前让用户选择要启动的分区. 而某些系统自带的多系统引导程序 (如 lilo, NT Loader 等) 则可以将自己的引导程序放在系统所处分区的第一个扇区中, 在 Linux 中即为 SuperBlock (其实 SuperBlock 是两个扇区). 注: 以上各步骤中使用的是标准 MBR, 其他多系统引导程序的引导过程与此不同.<br />
第二部分 技术资料<br />
第一章 扩展 Int13H 技术资料<br />
一. 简介<br />
设计扩展 Int13H 接口的目的是为了扩展 BIOS 的功能, 使其支持<br />
多于1024柱面的硬盘, 以及可移动介质的琐定, 解锁及弹出等功能.<br />
二. 数据结构<br />
1. 数据类型约定<br />
BYTE 1 字节整型 ( 8 位 )<br />
WORD 2 字节整型 ( 16 位 )<br />
DWORD 4 字节整型 ( 32 位 )<br />
QWORD 8 字节整型 ( 64 位 )<br />
2. 磁盘地址数据包 Disk Address Packet (DAP)<br />
DAP 是基于绝对扇区地址的, 因此利用 DAP, Int13H 可以轻松地逾<br />
越 1024 柱面的限制, 因为它根本就不需要 CHS 的概念.<br />
DAP 的结构如下:<br />
struct DiskAddressPacket<br />
{<br />
BYTE PacketSize; // 数据包尺寸(16字节)<br />
BYTE Reserved; // ==0<br />
WORD BlockCount; // 要传输的数据块个数(以扇区为单位)<br />
DWORD BufferAddr; // 传输缓冲地址(segment:offset)<br />
QWORD BlockNum; // 磁盘起始绝对块地址<br />
};<br />
PacketSize 保存了 DAP 结构的尺寸, 以便将来对其进行扩充. 在目前使用的扩展 Int13H 版本中 PacketSize 恒等于 16. 如果它小于16, 扩展 Int13H 将返回错误码( AH=01, CF=1 ). BlockCount 对于输入来说是需要传输的数据块总数, 对于输出来说 是实际传输的数据块个数. BlockCount = 0 表示不传输任何数据块. BufferAddr 是传输数据缓冲区的 32 位地址 (段地址:偏移量). 数据缓冲区必须位于常规内存以内(1M). BlockNum 表示的是从磁盘开始算起的绝对块地址(以扇区为单位), 与分区无关. 第一个块地址为 0. 一般来说, BlockNum 与 CHS 地址的关系是: BlockNum = cylinder * NumberOfHeads + head * SectorsPerTrack + sector - 1; 其中 cylinder, head, sector 是 CHS 地址, NumberOfHeads 是磁盘 的磁头数, SectorsPerTrack 是磁盘每磁道的扇区数. 也就是说 BlockNum 是沿着 扇区-&gt;磁道-&gt;柱面 的顺序记数的. 这一顺 序是由磁盘控制器虚拟的, 磁盘表面数据块的实际排列顺序可能与此不同 (如为了提高磁盘速度而设置的间隔因子将会打乱扇区的排列顺序).<br />
3. 驱动器参数数据包 Drive Parameters Packet<br />
驱动器参数数据包是在扩展 Int13H 的取得驱动器参数子功能调用中 使用的数据包. 格式如下:<br />
struct DriveParametersPacket<br />
{<br />
WORD InfoSize; // 数据包尺寸 (26 字节)<br />
WORD Flags; // 信息标志<br />
DWORD Cylinders; // 磁盘柱面数<br />
DWORD Heads; // 磁盘磁头数<br />
DWORD SectorsPerTrack; // 每磁道扇区数<br />
QWORD Sectors; // 磁盘总扇区数<br />
WORD SectorSize; // 扇区尺寸 (以字节为单位)<br />
};<br />
信息标志用于返回磁盘的附加信息, 每一位的定义如下:<br />
0 位:<br />
0 = 可能发生 DMA 边界错误<br />
1 = DMA 边界错误将被透明处理<br />
如果这位置 1, 表示 BIOS 将自动处理 DMA 边界错误, 也就是说<br />
错误代码 09H 永远也不会出现.<br />
1 位:<br />
0 = 未提供 CHS 信息<br />
1 = CHS 信息合法<br />
如果块设备的传统 CHS 几何信息不适当的话, 该位将置 0.<br />
2 位:<br />
0 = 驱动器不可移动<br />
1 = 驱动器可移动<br />
3 位: 表示该驱动器是否支持写入时校验.<br />
4 位:<br />
0 = 驱动器不具备介质更换检测线<br />
1 = 驱动器具备介质更换检测线<br />
5 位:<br />
0 = 驱动器不可锁定<br />
1 = 驱动器可以锁定<br />
要存取驱动器号大于 0x80 的可移动驱动器, 该位必须置 1<br />
(某些驱动器号为 0 到 0x7F 的设备也需要置位)<br />
6 位:<br />
0 = CHS 值是当前存储介质的值 (仅对于可移动介质), 如果<br />
驱动器中有存储介质, CHS 值将被返回.<br />
1 = CHS 值是驱动器支持的最大值 (此时驱动器中没有介质).<br />
7 - 15 位: 保留, 必须置 0.<br />
三. 接口规范<br />
1. 寄存器约定<br />
在扩展 Int13H 调用中一般使用如下寄存器约定:<br />
ds:di ==&gt; 磁盘地址数据包( disk address packet )<br />
dl ==&gt; 驱动器号<br />
ah ==&gt; 功能代码 / 返回码<br />
在基本 Int13H 调用中, 0 - 0x7F 之间的驱动器号代表可移动驱动器 0x80 - 0xFF 之间的驱动器号代表固定驱动器. 但在扩展 Int13H 调用中 0x80 - 0xFF 之间还包括一些新出现的可移动驱动器, 比如活动硬盘等. 这些驱动器支持先进的锁定,解锁等功能. ah 返回的错误码除了标准 Int13H 调用规定的基本错误码以外,又增加了以下错误码:<br />
B0h 驱动器中的介质未被锁定<br />
B1h 驱动器中的介质已经锁定<br />
B2h 介质是可移动的<br />
B3h 介质正在被使用<br />
B4h 锁定记数溢出<br />
B5h 合法的弹出请求失败<br />
2. API 子集介绍<br />
1.x 版的扩展 Int13H 调用中规定了两个主要的 API 子集. 第一个子集提供了访问大硬盘所必须的功能, 包括 检查扩展 In13H 是否存在( 41h ), 扩展读( 42h ), 扩展写( 43h ), 校验扇区( 44h ), 扩展定位( 47h ) 和 取得驱动器参数( 48h ). 第二个子集提供了对软件控制驱动器锁定和弹出的支持, 包括 检查扩展Int13H 是否存在( 41h ), 锁定/解锁驱动器( 45h ), 弹出驱动器( 46h ), 取得驱动器参数( 48h ), 取得扩展驱动器改变状态( 49h ), int 15h. 如果使用了调用规范中不支持的功能, BIOS 将返回错误码 ah = 01h, CF = 1.<br />
3. API 详解<br />
1) 检验扩展功能是否存在<br />
入口:<br />
AH = 41h<br />
BX = 55AAh<br />
DL = 驱动器号<br />
返回:<br />
CF = 0<br />
AH = 扩展功能的主版本号<br />
AL = 内部使用<br />
BX = AA55h<br />
CX = API 子集支持位图<br />
CF = 1<br />
AH = 错误码 01h, 无效命令<br />
这个调用检验对特定的驱动器是否存在扩展功能. 如果进位标志置 1 则此驱动器不支持扩展功能. 如果进位标志为 0, 同时 BX = AA55h, 则存在扩展功能. 此时 CX 的 0 位表示是否支持第一个子集, 1位表示是否支持第二个子集.对于 1.x 版的扩展 Int13H 来说, 主版本号 AH = 1. AL 是副版本号, 但这仅限于 BIOS 内部使用, 任何软件不得检查 AL 的值.<br />
2) 扩展读<br />
入口:<br />
AH = 42h<br />
DL = 驱动器号<br />
DS:DI = 磁盘地址数据包(Disk Address Packet)<br />
返回:<br />
CF = 0, AH = 0 成功<br />
CF = 1, AH = 错误码<br />
这个调用将磁盘上的数据读入内存. 如果出现错误, DAP 的 BlockCount项中则记录了出错前实际读取的数据块个数.<br />
3) 扩展写<br />
入口:<br />
AH = 43h<br />
AL<br />
0 位 = 0 关闭写校验<br />
1 打开写校验<br />
1 - 7 位保留, 置 0<br />
DL = 驱动器号<br />
DS:DI = 磁盘地址数据包(DAP)<br />
返回:<br />
CF = 0, AH = 0 成功<br />
CF = 1, AH = 错误码<br />
这个调用将内存中的数据写入磁盘. 如果打开了写校验选项, 但 BIOS不支持, 则会返回错误码 AH = 01h, CF = 1. 功能 48h 可以检测BIOS是否支持写校验. 如果出现错误, DAP 的 BlockCount 项中则记录了出错前实际写入的数据块个数.<br />
4) 校验扇区<br />
入口:<br />
AH = 44h<br />
DL = 驱动器号<br />
DS:DI = 磁盘地址数据包(Disk Address Packet)<br />
返回:<br />
CF = 0, AH = 0 成功<br />
CF = 1, AH = 错误码<br />
这个调用校验磁盘数据, 但并不将数据读入内存.如果出现错误, DAP 的BlockCount 项中则记录了出错前实际校验的数据块个数.<br />
5) 锁定/解锁驱动器<br />
入口:<br />
AH = 45h<br />
AL<br />
= 0 锁定驱动器<br />
= 1 驱动器解锁<br />
= 02 返回锁定/解锁状态<br />
= 03h-FFh - 保留<br />
DL = 驱动器号<br />
返回:<br />
CF = 0, AH = 0 成功<br />
CF = 1, AH = 错误码<br />
这个调用用来缩定指定驱动器中的介质. 所有标号大于等于 0x80 的可移动驱动器必须支持这个功能. 如果在支持可移动驱动器控制功能子集的固定驱动器上使用这个功能调用, 将会成功返回. 会成功返回. 驱动器必须支持最大255次锁定, 在所有锁定被解锁之前, 不能在物理上 将驱动器解锁. 解锁一个未锁定的驱动器,将返回错误码 AH= B0h. 如果锁定一个已锁定了255次的驱动器, 将返回错误码 AH = B4h. 锁定一个没有介质的驱动器是合法的.<br />
6) 弹出可移动驱动器中的介质<br />
入口:<br />
AH = 46h<br />
AL = 0 保留<br />
DL = 驱动器号<br />
返回:<br />
CF = 0, AH = 0 成功<br />
CF = 1, AH = 错误码<br />
这个调用用来弹出指定的可移动驱动器中的介质.<br />
所有标号大于等于 0x80 的可移动驱动器必须支持这个功能. 如果<br />
在支持可移动驱动器控制功能子集的固定驱动器上使用这个功能调用, 将<br />
会返回错误码 AH = B2h (介质不可移动). 如果试图弹出一个被锁定的介质<br />
将返回错误码 AH = B1h (介质被锁定).<br />
如果试图弹出一个没有介质的驱动器, 则返回错误码 Ah = 31h (驱动器<br />
中没有介质).<br />
中没有介质).<br />
如果试图弹出一个未锁定的可移动驱动器中的介质, Int13h会调用 Int15h<br />
(AH = 52h) 来检查弹出请求能否执行. 如果弹出请求被拒绝则返回错误码(同<br />
Int15h). 如果弹出请求被接受,但出现了其他错误, 则返回错误码 AH = B5h.<br />
7) 扩展定位<br />
入口:<br />
AH = 47h<br />
DL = 驱动器号<br />
DS:DI = 磁盘地址数据包(Disk Address Packet)<br />
返回:<br />
CF = 0, AH = 0 成功<br />
CF = 1, AH = 错误码<br />
这个调用将磁头定位到指定扇区.<br />
8) 取得驱动器参数<br />
入口:<br />
AH = 48h<br />
DL = 驱动器号<br />
DS:DI = 返回数据缓冲区地址<br />
返回:<br />
CF = 0, AH = 0 成功<br />
DS:DI 驱动器参数数据包地址, (参见前面的文章)<br />
CF = 1, AH = 错误码<br />
这个调用返回指定驱动器的参数.<br />
9) 取得扩展驱动器介质更换检测线状态<br />
入口:<br />
AH = 49h<br />
DL = 驱动器号<br />
返回:<br />
CF = 0, AH = 0 介质未更换<br />
CF = 1, AH = 06h 介质可能已更换<br />
这个调用返回指定驱动器的介质更换状态.<br />
这个调用与 Int13h AH = 16h 子功能调用相同, 只是允许任何驱动器标号. 如果对一台支持可移动介质功能子集的固定驱动器使用此功能,则永远返回 CF = 0, AH = 0. 简单地将可移动介质锁定再解锁就可以激活检测线, 而无须真正更换介质.<br />
10) Int 15h 可移动介质弹出支持<br />
入口:<br />
AH = 52h<br />
DL = 驱动器号<br />
返回:<br />
CF = 0, AH = 0 弹出请求可能可以执行<br />
CF = 1, AH = 错误码 B1h 或 B3h 弹出请求不能执行<br />
这个调用是由 Int13h AH=46h 弹出介质功能调用内部使用的.</p>
</div>
</td>
</tr>
</tbody>
</table>
