---
layout: post
title: 一致代码段和非一致代码段
date: 
type: post
published: false
status: private
categories:
- Blog
tags: []
meta:
  _edit_last: '1'
author:
  login: oxnz
  email: yunxinyi@gmail.com
  display_name: Will Z
  first_name: Will
  last_name: Z
---
<p>之所以出现这个定义是因为系统要安全:内核要和用户程序分开.内核一定要安全.不能被用户程序干涉. 但是有时候用户程序也需要读取内核的某些数据,怎么办呢? <!--more-->于是os将内核程序开辟一些可以供用用户程序访问的段.但是不允许用户程序写入数据. 1.内核不用知道用户程序的数据.内核不用调用用户程序的数据.内核不用转移到用户程序中来. 2.用户程序只能访问到内核的某些共享的段.我们称这些段为一致代码段 3.用户程序不能访问内核不共享的段. 1.在x86中的数据和代码是按段来存放的:[section] 2.程序是通过选择子/门调用等等来在段之间来回走动的. 3.每一个选择子/门调用选择子是有分等级的:这个是在选择符的结构中:RPL(最后2位) 4.每一个代码段/数据段也是有分等级的.:这个是在gdt描述符中. 调用的选择符和被调用的段都分了等级.哪么这些等级在哪里使用呢? 在一致代码段.也就是共享段中使用 既然是共享所以就有规则了: 对于一致代码段:也就是共享的段. 1.特权级高的程序不允许访问特权级低的数据:核心态不允许调用用户态的数据. 2.特权级低的程序可以访问到特权级高的数据.但是特权级不会改变: 用户态还是用户态.对于普通代码段.也就是非一致代码段: 0.只允许同级间访问. 1.绝对禁止不同级访问:核心态不用用户态.用户态也不使用核心态. 总结:似乎这些东西跟我们初学者预想的那样不同.核心态是老大.想用访问谁都可以.其实错了.结果恰恰相反. 这是因为防止用户篡改核心态的数据.导致核心态执行用户代码.而造成内核崩溃.内核坏了.什么事都可能发生. notes:要注意特权级和特权级数的问题. 特权级数 特权级 0 系统级:特权级高 特权级数低 3 用户级:特权级低 特权级数高</p>
