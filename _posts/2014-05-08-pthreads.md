---
layout: post
title: POSIX threads
date: 2014-05-08 15:29:33.000000000 +08:00
type: post
published: true
status: publish
categories:
- threading
tags: []
meta:
  _edit_last: '1'
  _wp_old_slug: '1594'
author:
  login: oxnz
  email: yunxinyi@gmail.com
  display_name: Will Z
  first_name: Will
  last_name: Z
---
<h2>介绍</h2>
<p>主要从使用方面讨论一下 pthreads。</p>
<ol>
<li>介绍</li>
<li>man 手册</li>
<li>实例代码</li>
<li>进阶</li>
<li>总结</li>
</ol>
<p><!--more--></p>
<h2>man 手册</h2>
<blockquote>
<pre class="crayon:false" style="color: #222222;"><span class="headline" style="font-weight: bold;">PTHREADS(7)               Linux Programmer's Manual              PTHREADS(7)</span>
</pre>
<h2 style="color: #a00000;"><a id="NAME" style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/pthreads.7.html#NAME"></a>NAME</h2>
<pre style="color: #222222;">       pthreads - POSIX threads
</pre>
<h2 style="color: #a00000;"><a id="DESCRIPTION" style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/pthreads.7.html#DESCRIPTION"></a>DESCRIPTION</h2>
<pre class="crayon:false" style="color: #222222;">       POSIX.1 specifies a set of interfaces (functions, header files) for
       threaded programming commonly known as POSIX threads, or Pthreads.  A
       single process can contain multiple threads, all of which are
       executing the same program.  <span style="color: #ff0000;">These threads share the same global
       memory (data and heap segments), but each thread has its own stack
       (automatic variables).</span>

       POSIX.1 also requires that threads share a range of other attributes
       (i.e., <span style="color: #ff0000;">these attributes are process-wide rather than per-thread</span>):

       -  process ID
       -  parent process ID
       -  process group ID and session ID
       -  controlling terminal
       -  user and group IDs
       -  open file descriptors
       -  record locks (see <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl(2)</a>)
       -  signal dispositions
       -  file mode creation mask (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/umask.2.html">umask(2)</a>)
       -  current directory (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/chdir.2.html">chdir(2)</a>) and root directory (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/chroot.2.html">chroot(2)</a>)
       -  interval timers (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/setitimer.2.html">setitimer(2)</a>) and POSIX timers (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/timer_create.2.html">timer_create(2)</a>)
       -  nice value (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/setpriority.2.html">setpriority(2)</a>)
       -  resource limits (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/setrlimit.2.html">setrlimit(2)</a>)
       -  measurements of the consumption of CPU time (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/times.2.html">times(2)</a>) and
          resources (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/getrusage.2.html">getrusage(2)</a>)

       As well as the stack, POSIX.1 specifies that various other attributes
       are <span style="color: #ff0000;">distinct for each thread</span>, including:

       -  thread ID (the <i style="color: #006000;">pthread_t</i> data type)
       -  signal mask (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_sigmask.3.html">pthread_sigmask(3)</a>)
       -  the <i style="color: #006000;"><a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/errno.3.html">errno</a></i> variable
       -  alternate signal stack (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/sigaltstack.2.html">sigaltstack(2)</a>)
       -  real-time scheduling policy and priority (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/sched_setscheduler.2.html">sched_setscheduler(2)</a>
          and <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/sched_setparam.2.html">sched_setparam(2)</a>)

       The following <span style="color: #ff0000;">Linux-specific</span> features are also <span style="color: #ff0000;">per-thread</span>:

       -  capabilities (see <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities(7)</a>)
       -  CPU affinity (<a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/sched_setaffinity.2.html">sched_setaffinity(2)</a>)

   <b style="color: #502000;">Pthreads function return values</b>
       Most pthreads functions return 0 on success, and an error number of
       failure.  Note that the <span style="color: #ff0000;">pthreads functions do not set</span> <i style="color: #006000;"><a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/errno.3.html">errno</a></i>.  For
       each of the pthreads functions that can return an error, POSIX.1-2001
       specifies that the function can <span style="color: #ff0000;">never fail with the error</span> <b style="color: #502000;">EINTR</b>.

   <b style="color: #502000;">Thread IDs</b>
       Each of the threads in a process has a unique thread identifier
       (stored in the type <i style="color: #006000;">pthread_t</i>).  This identifier is returned to the
       caller of <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create(3)</a>, and a thread can obtain its own thread
       identifier using <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_self.3.html">pthread_self(3)</a>.  Thread IDs are guaranteed to be
       unique only within a process.  A thread ID may be reused after a
       terminated thread has been joined, or a detached thread has
       terminated.  In all pthreads functions that accept a thread ID as an
       argument, that ID by definition refers to a thread in the same
       process as the caller.

   <b style="color: #502000;">Thread-safe functions</b>
       A thread-safe function is one that can be safely (i.e., it will
       deliver the same results regardless of whether it is) called from
       multiple threads at the same time.

       POSIX.1-2001 and POSIX.1-2008 require that all functions specified in
       the standard shall be thread-safe, <span style="color: #ff0000;">except for the following
       functions:</span>

           asctime()
           basename()
           catgets()
           crypt()
           ctermid() if passed a non-NULL argument
           ctime()
           dbm_clearerr()
           dbm_close()
           dbm_delete()
           dbm_error()
           dbm_fetch()
           dbm_firstkey()
           dbm_nextkey()
           dbm_open()
           dbm_store()
           dirname()
           dlerror()
           drand48()
           ecvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           encrypt()
           endgrent()
           endpwent()
           endutxent()
           fcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           ftw()
           gcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           getc_unlocked()
           getchar_unlocked()
           getdate()
           getenv()
           getgrent()
           getgrgid()
           getgrnam()
           gethostbyaddr() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           gethostbyname() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           gethostent()
           getlogin()
           getnetbyaddr()
           getnetbyname()
           getnetent()
           getopt()
           getprotobyname()
           getprotobynumber()
           getprotoent()
           getpwent()
           getpwnam()
           getpwuid()
           getservbyname()
           getservbyport()
           getservent()
           getutxent()
           getutxid()
           getutxline()
           gmtime()
           hcreate()
           hdestroy()
           hsearch()
           inet_ntoa()
           l64a()
           lgamma()
           lgammaf()
           lgammal()
           localeconv()
           localtime()
           lrand48()
           mrand48()
           nftw()
           nl_langinfo()
           ptsname()
           putc_unlocked()
           putchar_unlocked()
           putenv()
           pututxline()
           rand()
           readdir()
           setenv()
           setgrent()
           setkey()
           setpwent()
           setutxent()
           strerror()
           strsignal() [Added in POSIX.1-2008]
           strtok()
           system() [Added in POSIX.1-2008]
           tmpnam() if passed a non-NULL argument
           ttyname()
           unsetenv()
           wcrtomb() if its final argument is NULL
           wcsrtombs() if its final argument is NULL
           wcstombs()
           wctomb()

   <b style="color: #502000;">Async-cancel-safe functions</b>
       An async-cancel-safe function is one that can be safely called in an
       application where asynchronous cancelability is enabled (see
       <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_setcancelstate.3.html">pthread_setcancelstate(3)</a>).

       Only the following functions are required to be async-cancel-safe by
       POSIX.1-2001 and POSIX.1-2008:

           pthread_cancel()
           pthread_setcancelstate()
           pthread_setcanceltype()

   <b style="color: #502000;">Cancellation points</b>
       POSIX.1 specifies that certain functions must, and certain other
       functions may, be cancellation points.  If a thread is cancelable,
       its cancelability type is deferred, and a cancellation request is
       pending for the thread, then the thread is canceled when it calls a
       function that is a cancellation point.

       The following functions are required to be cancellation points by
       POSIX.1-2001 and/or POSIX.1-2008:

           accept()
           aio_suspend()
           clock_nanosleep()
           close()
           connect()
           creat()
           fcntl() F_SETLKW
           fdatasync()
           fsync()
           getmsg()
           getpmsg()
           lockf() F_LOCK
           mq_receive()
           mq_send()
           mq_timedreceive()
           mq_timedsend()
           msgrcv()
           msgsnd()
           msync()
           nanosleep()
           open()
           openat() [Added in POSIX.1-2008]
           pause()
           poll()
           pread()
           pselect()
           pthread_cond_timedwait()
           pthread_cond_wait()
           pthread_join()
           pthread_testcancel()
           putmsg()
           putpmsg()
           pwrite()
           read()
           readv()
           recv()
           recvfrom()
           recvmsg()
           select()
           sem_timedwait()
           sem_wait()
           send()
           sendmsg()
           sendto()
           sigpause() [POSIX.1-2001 only (moves to "may" list in POSIX.1-2008)]
           sigsuspend()
           sigtimedwait()
           sigwait()
           sigwaitinfo()
           sleep()
           system()
           tcdrain()
           usleep() [POSIX.1-2001 only (function removed in POSIX.1-2008)]
           wait()
           waitid()
           waitpid()
           write()
           writev()

       The following functions may be cancellation points according to
       POSIX.1-2001 and/or POSIX.1-2008:

           access()
           asctime()
           asctime_r()
           catclose()
           catgets()
           catopen()
           chmod() [Added in POSIX.1-2008]
           chown() [Added in POSIX.1-2008]
           closedir()
           closelog()
           ctermid()
           ctime()
           ctime_r()
           dbm_close()
           dbm_delete()
           dbm_fetch()
           dbm_nextkey()
           dbm_open()
           dbm_store()
           dlclose()
           dlopen()
           dprintf() [Added in POSIX.1-2008]
           endgrent()
           endhostent()
           endnetent()
           endprotoent()
           endpwent()
           endservent()
           endutxent()
           faccessat() [Added in POSIX.1-2008]
           fchmod() [Added in POSIX.1-2008]
           fchmodat() [Added in POSIX.1-2008]
           fchown() [Added in POSIX.1-2008]
           fchownat() [Added in POSIX.1-2008]
           fclose()
           fcntl() (for any value of cmd argument)
           fflush()
           fgetc()
           fgetpos()
           fgets()
           fgetwc()
           fgetws()
           fmtmsg()
           fopen()
           fpathconf()
           fprintf()
           fputc()
           fputs()
           fputwc()
           fputws()
           fread()
           freopen()
           fscanf()
           fseek()
           fseeko()
           fsetpos()
           fstat()
           fstatat() [Added in POSIX.1-2008]
           ftell()
           ftello()
           ftw()
           futimens() [Added in POSIX.1-2008]
           fwprintf()
           fwrite()
           fwscanf()
           getaddrinfo()
           getc()
           getc_unlocked()
           getchar()
           getchar_unlocked()
           getcwd()
           getdate()
           getdelim() [Added in POSIX.1-2008]
           getgrent()
           getgrgid()
           getgrgid_r()
           getgrnam()
           getgrnam_r()
           gethostbyaddr() [SUSv3 only (function removed in POSIX.1-2008)]
           gethostbyname() [SUSv3 only (function removed in POSIX.1-2008)]
           gethostent()
           gethostid()
           gethostname()
           getline() [Added in POSIX.1-2008]
           getlogin()
           getlogin_r()
           getnameinfo()
           getnetbyaddr()
           getnetbyname()
           getnetent()
           getopt() (if opterr is nonzero)
           getprotobyname()
           getprotobynumber()
           getprotoent()
           getpwent()
           getpwnam()
           getpwnam_r()
           getpwuid()
           getpwuid_r()
           gets()
           getservbyname()
           getservbyport()
           getservent()
           getutxent()
           getutxid()
           getutxline()
           getwc()
           getwchar()
           getwd() [SUSv3 only (function removed in POSIX.1-2008)]
           glob()
           iconv_close()
           iconv_open()
           ioctl()
           link()
           linkat() [Added in POSIX.1-2008]
           lio_listio() [Added in POSIX.1-2008]
           localtime()
           localtime_r()
           lockf() [Added in POSIX.1-2008]
           lseek()
           lstat()
           mkdir() [Added in POSIX.1-2008]
           mkdirat() [Added in POSIX.1-2008]
           mkdtemp() [Added in POSIX.1-2008]
           mkfifo() [Added in POSIX.1-2008]
           mkfifoat() [Added in POSIX.1-2008]
           mknod() [Added in POSIX.1-2008]
           mknodat() [Added in POSIX.1-2008]
           mkstemp()
           mktime()
           nftw()
           opendir()
           openlog()
           pathconf()
           pclose()
           perror()
           popen()
           posix_fadvise()
           posix_fallocate()
           posix_madvise()
           posix_openpt()
           posix_spawn()
           posix_spawnp()
           posix_trace_clear()
           posix_trace_close()
           posix_trace_create()
           posix_trace_create_withlog()
           posix_trace_eventtypelist_getnext_id()
           posix_trace_eventtypelist_rewind()
           posix_trace_flush()
           posix_trace_get_attr()
           posix_trace_get_filter()
           posix_trace_get_status()
           posix_trace_getnext_event()
           posix_trace_open()
           posix_trace_rewind()
           posix_trace_set_filter()
           posix_trace_shutdown()
           posix_trace_timedgetnext_event()
           posix_typed_mem_open()
           printf()
           psiginfo() [Added in POSIX.1-2008]
           psignal() [Added in POSIX.1-2008]
           pthread_rwlock_rdlock()
           pthread_rwlock_timedrdlock()
           pthread_rwlock_timedwrlock()
           pthread_rwlock_wrlock()
           putc()
           putc_unlocked()
           putchar()
           putchar_unlocked()
           puts()
           pututxline()
           putwc()
           putwchar()
           readdir()
           readdir_r()
           readlink() [Added in POSIX.1-2008]
           readlinkat() [Added in POSIX.1-2008]
           remove()
           rename()
           renameat() [Added in POSIX.1-2008]
           rewind()
           rewinddir()
           scandir() [Added in POSIX.1-2008]
           scanf()
           seekdir()
           semop()
           setgrent()
           sethostent()
           setnetent()
           setprotoent()
           setpwent()
           setservent()
           setutxent()
           sigpause() [Added in POSIX.1-2008]
           stat()
           strerror()
           strerror_r()
           strftime()
           symlink()
           symlinkat() [Added in POSIX.1-2008]
           sync()
           syslog()
           tmpfile()
           tmpnam()
           ttyname()
           ttyname_r()
           tzset()
           ungetc()
           ungetwc()
           unlink()
           unlinkat() [Added in POSIX.1-2008]
           utime() [Added in POSIX.1-2008]
           utimensat() [Added in POSIX.1-2008]
           utimes() [Added in POSIX.1-2008]
           vdprintf() [Added in POSIX.1-2008]
           vfprintf()
           vfwprintf()
           vprintf()
           vwprintf()
           wcsftime()
           wordexp()
           wprintf()
           wscanf()

       An implementation may also mark other functions not specified in the
       standard as cancellation points.  In particular, an implementation is
       likely to mark any nonstandard function that may block as a
       cancellation point.  (This includes most functions that can touch
       files.)

   <b style="color: #502000;">Compiling on Linux</b>
       On Linux, programs that use the Pthreads API should be compiled using
       <i style="color: #006000;">cc -pthread</i>.

   <b style="color: #502000;">Linux implementations of POSIX threads</b>
       Over time, two threading implementations have been provided by the
       GNU C library on Linux:

       <b style="color: #502000;">LinuxThreads</b>
              This is the original Pthreads implementation.  Since glibc
              2.4, this implementation is no longer supported.

       <b style="color: #502000;">NPTL </b>(Native POSIX Threads Library)
              This is the modern Pthreads implementation.  By comparison
              with LinuxThreads, NPTL provides closer conformance to the
              requirements of the POSIX.1 specification and better
              performance when creating large numbers of threads.  NPTL is
              available since glibc 2.3.2, and requires features that are
              present in the Linux 2.6 kernel.

       <span style="color: #ff0000;">Both of these are so-called 1:1 implementations, meaning that each
       thread maps to a kernel scheduling entity.</span>  Both threading
       implementations employ the Linux <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/clone.2.html">clone(2)</a> system call.  In NPTL,
       thread synchronization primitives (mutexes, thread joining, and so
       on) are implemented using the Linux <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/futex.2.html">futex(2)</a> system call.

   <b style="color: #502000;">LinuxThreads</b>
       The notable features of this implementation are the following:

       -  In addition to the main (initial) thread, and the threads that the
          program creates using <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create(3)</a>, the implementation
          creates a "manager" thread.  This thread handles thread creation
          and termination.  (Problems can result if this thread is
          inadvertently killed.)

       -  Signals are used internally by the implementation.  On Linux 2.2
          and later, the first three real-time signals are used (see also
          <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/signal.7.html">signal(7)</a>).  On older Linux kernels, <b style="color: #502000;">SIGUSR1 </b>and <b style="color: #502000;">SIGUSR2 </b>are used.
          Applications must avoid the use of whichever set of signals is
          employed by the implementation.

       -  Threads do not share process IDs.  (In effect, LinuxThreads
          threads are implemented as processes which share more information
          than usual, but which do not share a common process ID.)
          LinuxThreads threads (including the manager thread) are visible as
          separate processes using <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man1/ps.1.html">ps(1)</a>.

       The LinuxThreads implementation deviates from the POSIX.1
       specification in a number of ways, including the following:

       -  Calls to <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/getpid.2.html">getpid(2)</a> return a different value in each thread.
       -  Calls to <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/getppid.2.html">getppid(2)</a> in threads other than the main thread return
          the process ID of the manager thread; instead <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/getppid.2.html">getppid(2)</a> in these
          threads should return the same value as <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/getppid.2.html">getppid(2)</a> in the main
          thread.
       -  When one thread creates a new child process using <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a>, any
          thread should be able to <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/wait.2.html">wait(2)</a> on the child.  However, the
          implementation only allows the thread that created the child to
          <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/wait.2.html">wait(2)</a> on it.
       -  When a thread calls <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a>, all other threads are terminated
          (as required by POSIX.1).  However, the resulting process has the
          same PID as the thread that called <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a>: it should have the
          same PID as the main thread.
       -  Threads do not share user and group IDs.  This can cause
          complications with set-user-ID programs and can cause failures in
          Pthreads functions if an application changes its credentials using
          <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/seteuid.2.html">seteuid(2)</a> or similar.

       -  Threads do not share a common session ID and process group ID.

       -  Threads do not share record locks created using <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl(2)</a>.

       -  The information returned by <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/times.2.html">times(2)</a> and <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/getrusage.2.html">getrusage(2)</a> is per-
          thread rather than process-wide.

       -  Threads do not share semaphore undo values (see <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/semop.2.html">semop(2)</a>).

       -  Threads do not share interval timers.

       -  Threads do not share a common nice value.

       -  POSIX.1 distinguishes the notions of signals that are directed to
          the process as a whole and signals that are directed to individual
          threads.  According to POSIX.1, a process-directed signal (sent
          using <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/kill.2.html">kill(2)</a>, for example) should be handled by a single,
          arbitrarily selected thread within the process.  LinuxThreads does
          not support the notion of process-directed signals: signals may be
          sent only to specific threads.

       -  Threads have distinct alternate signal stack settings.  However, a
          new thread's alternate signal stack settings are copied from the
          thread that created it, so that the threads initially share an
          alternate signal stack.  (A new thread should start with no
          alternate signal stack defined.  If two threads handle signals on
          their shared alternate signal stack at the same time,
          unpredictable program failures are likely to occur.)

   <b style="color: #502000;">NPTL</b>
       With NPTL, all of the threads in a process are placed in the same
       thread group; all members of a thread group share the same PID.  NPTL
       does not employ a manager thread.  NPTL makes internal use of the
       first two real-time signals (see also <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/signal.7.html">signal(7)</a>); these signals
       cannot be used in applications.

       NPTL still has at least one nonconformance with POSIX.1:

       -  <span style="color: #ff0000;">Threads do not share a common nice value.</span>

       Some NPTL nonconformances occur only with older kernels:

       -  The information returned by <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/times.2.html">times(2)</a> and <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/getrusage.2.html">getrusage(2)</a> is per-
          thread rather than process-wide (fixed in kernel 2.6.9).

       -  Threads do not share resource limits (fixed in kernel 2.6.10).

       -  Threads do not share interval timers (fixed in kernel 2.6.12).

       -  Only the main thread is permitted to start a new session using
          <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/setsid.2.html">setsid(2)</a> (fixed in kernel 2.6.16).

       -  Only the main thread is permitted to make the process into a
          process group leader using <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/setpgid.2.html">setpgid(2)</a> (fixed in kernel 2.6.16).

       -  Threads have distinct alternate signal stack settings.  However, a
          new thread's alternate signal stack settings are copied from the
          thread that created it, so that the threads initially share an
          alternate signal stack (fixed in kernel 2.6.16).

       Note the following further points about the NPTL implementation:

       -  If the stack size soft resource limit (see the description of
          <b style="color: #502000;">RLIMIT_STACK </b>in <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/setrlimit.2.html">setrlimit(2)</a>) is set to a value other than
          <i style="color: #006000;">unlimited</i>, then this value defines the default stack size for new
          threads.  To be effective, this limit must be set before the
          program is executed, perhaps using the <i style="color: #006000;">ulimit -s</i> shell built-in
          command (<i style="color: #006000;">limit stacksize</i> in the C shell).

   <b style="color: #502000;">Determining the threading implementation</b>
       Since glibc 2.3.2, the <b style="color: #502000;">getconf</b>(1) command can be used to determine
       the system's threading implementation, for example:

           bash$ getconf GNU_LIBPTHREAD_VERSION
           NPTL 2.3.4

       With older glibc versions, a command such as the following should be
       sufficient to determine the default threading implementation:

           bash$ $( ldd /bin/ls | grep libc.so | awk '{print $3}' ) |
                           egrep -i 'threads|nptl'
                   Native POSIX Threads Library by Ulrich Drepper et al

   <b style="color: #502000;">Selecting the threading implementation: LD_ASSUME_KERNEL</b>
       On systems with a glibc that supports both LinuxThreads and NPTL
       (i.e., glibc 2.3.<i style="color: #006000;">x</i>), the <b style="color: #502000;">LD_ASSUME_KERNEL </b>environment variable can be
       used to override the dynamic linker's default choice of threading
       implementation.  This variable tells the dynamic linker to assume
       that it is running on top of a particular kernel version.  By
       specifying a kernel version that does not provide the support
       required by NPTL, we can force the use of LinuxThreads.  (The most
       likely reason for doing this is to run a (broken) application that
       depends on some nonconformant behavior in LinuxThreads.)  For
       example:

           bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so |
                           awk '{print $3}' ) | egrep -i 'threads|ntpl'
                   linuxthreads-0.10 by Xavier Leroy
</pre>
<h2 style="color: #a00000;"><a id="SEE_ALSO" style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/pthreads.7.html#SEE_ALSO"></a>SEE ALSO</h2>
<pre class="crayon:false" style="color: #222222;">       <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/clone.2.html">clone(2)</a>, <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/futex.2.html">futex(2)</a>, <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man2/gettid.2.html">gettid(2)</a>, <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man5/proc.5.html">proc(5)</a>, <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/futex.7.html">futex(7)</a>, <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/sigevent.7.html">sigevent(7)</a>,
       <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/signal.7.html">signal(7)</a>,

       Various Pthreads manual pages, for example: <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_attr_init.3.html">pthread_attr_init(3)</a>,
       <b style="color: #502000;">pthread_atfork</b>(3), <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_cancel.3.html">pthread_cancel(3)</a>, <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_cleanup_push.3.html">pthread_cleanup_push(3)</a>,
       <b style="color: #502000;">pthread_cond_signal</b>(3), <b style="color: #502000;">pthread_cond_wait</b>(3), <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_create.3.html">pthread_create(3)</a>,
       <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_detach.3.html">pthread_detach(3)</a>, <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_equal.3.html">pthread_equal(3)</a>, <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_exit.3.html">pthread_exit(3)</a>,
       <b style="color: #502000;">pthread_key_create</b>(3), <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_kill.3.html">pthread_kill(3)</a>, <b style="color: #502000;">pthread_mutex_lock</b>(3),
       <b style="color: #502000;">pthread_mutex_unlock</b>(3), <b style="color: #502000;">pthread_once</b>(3), <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_setcancelstate.3.html">pthread_setcancelstate(3)</a>,
       <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_setcanceltype.3.html">pthread_setcanceltype(3)</a>, <b style="color: #502000;">pthread_setspecific</b>(3), <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_sigmask.3.html">pthread_sigmask(3)</a>,
       <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_sigqueue.3.html">pthread_sigqueue(3)</a>, and <a style="color: #4488bb;" href="http://man7.org/linux/man-pages/man3/pthread_testcancel.3.html">pthread_testcancel(3)</a>
</pre>
<h2 style="color: #a00000;"><a id="COLOPHON" style="color: #4488bb;" href="http://man7.org/linux/man-pages/man7/pthreads.7.html#COLOPHON"></a>COLOPHON</h2>
<pre class="crayon:false" style="color: #222222;">       This page is part of release 3.65 of the Linux <i style="color: #006000;">man-pages</i> project.  A
       description of the project, and information about reporting bugs, can
       be found at <a style="color: #4488bb;" href="http://www.kernel.org/doc/man-pages/">http://www.kernel.org/doc/man-pages/</a>.

<span class="footline" style="font-weight: bold;">Linux                            2010-11-14                      PTHREADS(7)</span></pre>
</blockquote>
<h2>futex</h2>
<blockquote>
<p style="text-align: right;">引用自：<a title="Linux Futex的设计与实现" href="http://blog.csdn.net/jianchaolv/article/details/7544316" target="_blank">Linux Futex的设计与实现</a></p>
<p>1. 什么是Futex<br />
Futex 是Fast Userspace muTexes的缩写，由Hubertus Franke, Matthew Kirkwood, Ingo Molnar and Rusty Russell共同设计完成。几位都是linux领域的专家，其中可能Ingo Molnar大家更熟悉一些，毕竟是O(1)调度器和CFS的实现者。</p>
<p>Futex按英文翻译过来就是快速用户空间互斥体。其设计思想其实 不难理解，在传统的Unix系统中，System V IPC(inter process communication)，如 semaphores, msgqueues, sockets还有文件锁机制(flock())等进程间同步机制都是对一个内核对象操作来完成的，这个内核对象对要同步的进程都是可见的，其提供了共享 的状态信息和原子操作。当进程间要同步的时候必须要通过系统调用(如semop())在内核中完成。可是经研究发现，很多同步是无竞争的，即某个进程进入 互斥区，到再从某个互斥区出来这段时间，常常是没有进程也要进这个互斥区或者请求同一同步变量的。但是在这种情况下，这个进程也要陷入内核去看看有没有人 和它竞争，退出的时侯还要陷入内核去看看有没有进程等待在同一同步变量上。这些不必要的系统调用(或者说内核陷入)造成了大量的性能开销。为了解决这个问 题，Futex就应运而生，Futex是一种用户态和内核态混合的同步机制。首先，同步的进程间通过mmap共享一段内存，futex变量就位于这段共享 的内存中且操作是原子的，当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，如果没有竞争发生，则只修改futex,而不 用再执行系统调用了。当通过访问futex变量告诉进程有竞争发生，则还是得执行系统调用去完成相应的处理(wait 或者 wake up)。简单的说，futex就是通过在用户态的检查，（motivation）如果了解到没有竞争就不用陷入内核了，大大提高了low-contention时候的效率。 Linux从2.5.7开始支持Futex。</p>
<p>2. Futex系统调用<br />
Futex是一种用户态和内核态混合机制，所以需要两个部分合作完成，linux上提供了sys_futex系统调用，对进程竞争情况下的同步处理提供支持。<br />
其原型和系统调用号为</p>
<pre class="lang:default decode:true ">#include &lt;linux/futex.h&gt;
#include &lt;sys/time.h&gt;

int futex(int *uaddr, int op, int val, const struct timespec *timeout,
          int *uaddr2, int val3);</pre>
<p>虽然参数有点长，其实常用的就是前面三个，后面的timeout大家都能理解，其他的也常被ignore。<br />
uaddr就是用户态下共享内存的地址，里面存放的是一个对齐的整型计数器。<br />
op存放着操作类型。定义的有5中，这里我简单的介绍一下两种，剩下的感兴趣的自己去man futex<br />
FUTEX_WAIT: 原子性的检查uaddr中计数器的值是否为val,如果是则让进程休眠，直到FUTEX_WAKE或者超时(time-out)。也就是把进程挂到uaddr相对应的等待队列上去。<br />
FUTEX_WAKE: 最多唤醒val个等待在uaddr上进程。</p>
<p>可见FUTEX_WAIT和FUTEX_WAKE只是用来挂起或者唤醒进程，当然这部分工作也只能在内核态下完成。有些人尝试着直接使用futex系统调 用来实现进程同步，并寄希望获得futex的性能优势，这是有问题的。应该区分futex同步机制和futex系统调用。futex同步机制还包括用户态 下的操作，我们将在下节提到。</p>
<p>3. Futex同步机制<br />
所有的futex同步操作都应该从用户空间开始，首先创建一个futex同步变量，也就是位于共享内存的一个整型计数器。<br />
当 进程尝试持有锁或者要进入互斥区的时候，对futex执行"down"操作，即原子性的给futex同步变量减1。如果同步变量变为0，则没有竞争发生， 进程照常执行。如果同步变量是个负数，则意味着有竞争发生，需要调用futex系统调用的futex_wait操作休眠当前进程。<br />
当进程释放锁或 者要离开互斥区的时候，对futex进行"up"操作，即原子性的给futex同步变量加1。如果同步变量由0变成1，则没有竞争发生，进程照常执行。如 果加之前同步变量是负数，则意味着有竞争发生，需要调用futex系统调用的futex_wake操作唤醒一个或者多个等待进程。</p>
<p>这里的原子性加减通常是用CAS(Compare and Swap)完成的，与平台相关。CAS的基本形式是：CAS(addr,old,new),当addr中存放的值等于old时，用new对其替换。在x86平台上有专门的一条指令来完成它: cmpxchg。</p>
<p>可见: futex是从用户态开始，由用户态和核心态协调完成的。</p>
<p>4. 进/线程利用futex同步<br />
进程或者线程都可以利用futex来进行同步。<br />
对于线程，情况比较简单，因为线程共享虚拟内存空间，虚拟地址就可以唯一的标识出futex变量，即线程用同样的虚拟地址来访问futex变量。<br />
对 于进程，情况相对复杂，因为进程有独立的虚拟内存空间，只有通过<code>mmap()</code>让它们共享一段地址空间来使用futex变量。每个进程用来访问futex的 虚拟地址可以是不一样的，只要系统知道所有的这些虚拟地址都映射到同一个物理内存地址，并用物理内存地址来唯一标识futex变量。</p>
<p>小结：</p>
<ol>
<li>Futex变量的特征：1)位于共享的用户空间中 2)是一个32位的整型 3)对它的操作是原子的</li>
<li>Futex在程序low-contention的时候能获得比传统同步机制更好的性能。</li>
<li>不要直接使用Futex系统调用。</li>
<li>Futex同步机制可以用于进程间同步，也可以用于线程间同步。</li>
</ol>
</blockquote>
<h2>线程同步</h2>
<p>在linux中进行多线程开发，同步是不可回避的一个问题。在POSIX标准中定义了三种线程同步机制: Mutexes(互斥量), Condition Variables(条件变量)和POSIX Semaphores(信号量)。NPTL基本上实现了POSIX，而glibc又使用NPTL作为自己的线程库。因此glibc中包含了这三种同步机制 的实现(当然还包括其他的同步机制，如APUE里提到的读写锁)。</p>
<p>信号量例子：</p>
<pre class="lang:default decode:true">sem_t *sem;

void *taskfunc(void *arg) {
    pthread_t ptid = *(pthread_t *)(arg);
    errpro(-1 == sem_wait(sem), "sem_wait"); // request
    printf("task of thread [%lu] wait semn", (unsigned long)ptid);
    sleep(2);
    int sv = 0;
    sem_getvalue(sem, &amp;sv);
    printf("sem value = %dn", sv);
    sem_post(sem); // release
    printf("task of thread [%lu] post semn", (unsigned long)ptid);
    return NULL;
}

#define TCNT 5U // thread count

int main(int , char **) {
    sem_t s;
    sem = &amp;s;
    errpro(-1 == sem_init(sem, 0, 2), "sem_init");
    pthread_t ptids[TCNT];

    for (int i = 0; i &lt; 5; ++i) { // create five threads
        errpro(0 != pthread_create(&amp;ptids[i], NULL, taskfunc, &amp;ptids[i]),
                "pthread_create");
    }
    for (int i = 0; i &lt; 5; ++i) {
        pthread_join(ptids[i], NULL);
    }

    errpro(-1 == sem_destroy(sem), "sem_destroy");

    return 0;
}
// 运行结果：
% ./test
task of thread [4422524928] wait sem
task of thread [4423061504] wait sem
sem value = 0
task of thread [4422524928] post sem
task of thread [4423598080] wait sem
sem value = 0
task of thread [4423061504] post sem
task of thread [4424134656] wait sem
sem value = 0
task of thread [4423598080] post sem
task of thread [4424671232] wait sem
sem value = 0
task of thread [4424134656] post sem
sem value = 0
task of thread [4424671232] post sem</pre>
<p><strong>posix 有名信号灯</strong></p>
<p>posix 有名信号灯是通过内核持续的，一个进程创建一个信号灯，另外的进程可以通过该信号灯的外部名（创建信号灯使用的文件名）来访问它。posix基于内存的信 号灯的持续性却是不定的，如果基于内存的信号灯是由单个进程内的各个线程共享的，那么该信号灯就是随进程持续的，当该进程终止时它也会消失。如果某个基于 内存的信号灯是在不同进程间同步的，该信号灯必须存放在共享内存区中，这要只要该共享内存区存在，该信号灯就存在。</p>
<p>命名信号量例子：</p>
<pre class="lang:default decode:true">sem_t *sem;

void *taskfunc(void *arg) {
    pthread_t ptid = *(pthread_t *)(arg);
    errpro(-1 == sem_wait(sem), "sem_wait"); // request
    printf("task of thread [%lu] wait semn", (unsigned long)ptid);
    sleep(2);
    int sv = 0;
    sem_getvalue(sem, &amp;sv);
    printf("sem value = %dn", sv);
    sem_post(sem); // release
    printf("task of thread [%lu] post semn", (unsigned long)ptid);
    return NULL;
}

#define TCNT 5U // thread count
#define SEMPATH "./sem" // sem path

int main(int , char **) {
    sem = sem_open(SEMPATH, O_CREAT|O_EXCL, 0644, 2);
    errpro(SEM_FAILED == sem, "sem_open");
    pthread_t ptids[TCNT];

    for (int i = 0; i &lt; 5; ++i) { // create five threads
        errpro(0 != pthread_create(&amp;ptids[i], NULL, taskfunc, &amp;ptids[i]),
                "pthread_create");
    }
    for (int i = 0; i &lt; 5; ++i) {
        pthread_join(ptids[i], NULL);
    }

    errpro(-1 == sem_close(sem), "sem_close");
    errpro(-1 == sem_unlink(SEMPATH), "sem_unlink");

    return 0;
}</pre>
<p>Mutex</p>
<blockquote>
<h2 style="color: #000000;">Name</h2>
<p><span style="color: #000000;">pthread_mutex_destroy, pthread_mutex_init - destroy and initialize a mutex</span></p>
<h2 style="color: #000000;">Synopsis</h2>
<p style="color: #000000;"><b>#include &lt;<a style="color: #660000;" href="http://linux.die.net/include/pthread.h" rel="nofollow">pthread.h</a>&gt;<br />
</b></p>
<p style="color: #000000;">int pthread_mutex_destroy(pthread_mutex_t *<i>mutex</i><b>);<br />
</b>int pthread_mutex_init(pthread_mutex_t *restrict <i>mutex</i><b>,<br />
</b>const pthread_mutexattr_t *restrict <i>attr</i><b>);<br />
</b>pthread_mutex_t <i>mutex</i> <b>= PTHREAD_MUTEX_INITIALIZER;<br />
</b></p>
<h2 style="color: #000000;">Description</h2>
<p style="color: #000000;">The <i>pthread_mutex_destroy</i>() function shall destroy the mutex object referenced by <i>mutex</i>; the mutex object becomes, in effect, uninitialized. An implementation may cause <i>pthread_mutex_destroy</i>() to set the object referenced by <i>mutex</i> to an invalid value. A destroyed mutex object can be reinitialized using <i>pthread_mutex_init</i>(); the results of otherwise referencing the object after it has been destroyed are undefined.</p>
<p style="color: #000000;">It shall be safe to destroy an initialized mutex that is unlocked. Attempting to destroy a locked mutex results in undefined behavior.</p>
<p style="color: #000000;">The <i>pthread_mutex_init</i>() function shall initialize the mutex referenced by <i>mutex</i> with attributes specified by <i>attr</i>. If <i>attr</i> is NULL, the default mutex attributes are used; the effect shall be the same as passing the address of a default mutex attributes object. Upon successful initialization, the state of the mutex becomes initialized and unlocked.</p>
<p style="color: #000000;">Only <i>mutex</i> itself may be used for performing synchronization. The result of referring to copies of <i>mutex</i> in calls to <i>pthread_mutex_lock</i>(),<i>pthread_mutex_trylock</i>(), <i>pthread_mutex_unlock</i>(), and <i>pthread_mutex_destroy</i>() is undefined.</p>
<p style="color: #000000;">Attempting to initialize an already initialized mutex results in undefined behavior.</p>
<p style="color: #000000;">In cases where default mutex attributes are appropriate, the macro PTHREAD_MUTEX_INITIALIZER can be used to initialize mutexes that are statically allocated. The effect shall be equivalent to dynamic initialization by a call to <i>pthread_mutex_init</i>() with parameter <i>attr</i> specified as NULL, except that no error checks are performed.</p>
<h2 style="color: #000000;">Return Value</h2>
<p style="color: #000000;">If successful, the <i>pthread_mutex_destroy</i>() and <i>pthread_mutex_init</i>() functions shall return zero; otherwise, an error number shall be returned to indicate the error.</p>
<p style="color: #000000;">The [EBUSY] and [EINVAL] error checks, if implemented, act as if they were performed immediately at the beginning of processing for the function and shall cause an error return prior to modifying the state of the mutex specified by <i>mutex</i>.</p>
</blockquote>
<p>程序实例：</p>
<pre class="lang:default decode:true">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int val; // global value used by per thread

void *taskfunc(void *arg) {
    pthread_t ptid = *(pthread_t *)(arg);
    for (int i = 0; i &lt; 2; ++i) {
        pthread_mutex_lock(&amp;mutex);
        int v = val + 1;
        printf("task of thread [%lu] with val = [%d]n", (unsigned long)ptid,
                v);
        val = v;
        sleep(2);
        pthread_mutex_unlock(&amp;mutex);
    }
    return NULL;
}

#define TCNT 5U // thread count

int main(int , char **) {
    pthread_t ptids[TCNT];

    for (int i = 0; i &lt; 5; ++i) { // create five threads
        errpro(0 != pthread_create(&amp;ptids[i], NULL, taskfunc, &amp;ptids[i]),
                "pthread_create");
    }
    for (int i = 0; i &lt; 5; ++i) {
        pthread_join(ptids[i], NULL);
    }


    return 0;
}
// 程序输出：
% ./test
task of thread [4523405312] with val = [1]
task of thread [4523941888] with val = [2]
task of thread [4524478464] with val = [3]
task of thread [4525015040] with val = [4]
task of thread [4525551616] with val = [5]
task of thread [4523405312] with val = [6]
task of thread [4523941888] with val = [7]
task of thread [4524478464] with val = [8]
task of thread [4525015040] with val = [9]
task of thread [4525551616] with val = [10]</pre>
<p>参考：</p>
<ol>
<li><a title="Posix信号灯" href="http://www.360doc.com/content/13/1108/09/7775902_327590125.shtml" target="_blank">http://www.360doc.com/content/13/1108/09/7775902_327590125.shtml</a></li>
<li><a title="POSIX 线程详解" href="http://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html" target="_blank">POSIX 线程详解</a></li>
<li><a href="http://blog.chinaunix.net/uid-26921272-id-3203633.html">POSIX详解pthread_mutex_lock</a><span style="color: #565656;"> </span></li>
</ol>
